[{"title":"New Website","type":0,"sectionRef":"#","url":"blog/new-website/","content":"Welcome to the new Rojo website! The new Rojo website uses Docusaurus, a static site generator focused on building great documentation websites. The bulk of the work on this project was done by unix-system. Send them your thanks the next time you see them!","keywords":""},{"title":"Introduction","type":0,"sectionRef":"#","url":"docs/v0.5/","content":"","keywords":""},{"title":"Why Rojo?​","type":1,"pageTitle":"Introduction","url":"docs/v0.5/#why-rojo","content":"Adding a tool like Rojo to your Roblox workflow can be daunting, but it comes with some key advantages. "},{"title":"Tools​","type":1,"pageTitle":"Introduction","url":"docs/v0.5/#tools","content":"There are decades of excellent tools available that operate on files. With Rojo, it's possible to take advantage of any of them! Popular tools that are tailored towards Roblox or Lua in general: Selene, a static analysis tool to help you write better LuaStyLua, a formatter that helps keep your code in a consistent styleWally, a package manager for Roblox projectsMoonwave, a documentation generator for Lua projects "},{"title":"Rojo at RDC 2019​","type":1,"pageTitle":"Introduction","url":"docs/v0.5/#rojo-at-rdc-2019","content":"Nathan Riemer (Kampfkarren) gave a talk at RDC 2019 talking about some of the benefits of using a tool like Rojo.  "},{"title":"External Text Editors​","type":1,"pageTitle":"Introduction","url":"docs/v0.5/#external-text-editors","content":"Rojo opens the door to use the absolute best text editors in the world and their rich plugin ecosystems. Some very popular editors include Visual Studio Code and Sublime Text. These advanced text editors have features like multi-cursor editing, go-to symbol, multi-file regex find and replace, bookmarks and much more. Many Rojo VS Code users also use extensions like: vscode-rbxluaRoblox Lua AutocompletesTabNine "},{"title":"Version Control​","type":1,"pageTitle":"Introduction","url":"docs/v0.5/#version-control","content":"By building your game (or just the scripts) as individual files on the filesystem, it becomes easy to start using professional-grade version control tools like Git and GitHub. Hundreds of thousands of companies and individual developers use Git to version their software projects. With Rojo, Roblox developers can take advantage of the best collaboration tool around. Using a repository hosting service like GitHub or GitLab brings powerful features to Roblox developers like code reviews and issue tracking that professional engineers can't live without. "},{"title":"TypeScript​","type":1,"pageTitle":"Introduction","url":"docs/v0.5/#typescript","content":"TypeScript enables static type safety, which helps prevent typos and adds unparalleled autocompletion. It also brings features like arrow functions, object destructuring, functional programming methods, and more! With Rojo, you can use roblox-ts to compile TypeScript to Lua and take advantage of a huge ecosystem of TypeScript tooling. It's also possible to use other languages that compile to Lua like MoonScript and Haxe. "},{"title":"Porting an Existing Game","type":0,"sectionRef":"#","url":"docs/v0.5/getting-started/existing-game/","content":"","keywords":""},{"title":"Prepare Your Game​","type":1,"pageTitle":"Porting an Existing Game","url":"docs/v0.5/getting-started/existing-game/#prepare-your-game","content":"Not all Roblox idioms translate to the filesystem well. If possible, it's easiest to refactor your game slightly to reduce reliance on these before introducing Rojo. Even if you don't adopt Rojo, these ideas may still improve your game's structure! "},{"title":"Move Code into Fewer Places​","type":1,"pageTitle":"Porting an Existing Game","url":"docs/v0.5/getting-started/existing-game/#move-code-into-fewer-places","content":"Inside Roblox, it is common to have scripts stashed away in instances like GUI components, parts in the main scene, or in objects like Tools. Roblox games often also contain several copies of the same script, like old school lava bricks in an obstacle course, or the AI behavior for a zombie. Most software projects outside Roblox have a single location, like a folder named src, that all code goes into. By moving most of your code into services like ReplicatedStorage, ServerScriptService, and StarterPlayer, it becomes easier to find what you're looking for. Rewriting this code to use modern Roblox features like CollectionService can make it easier to understand, easier to work on, and more friendly to Rojo. "},{"title":"rbxlx-to-rojo​","type":1,"pageTitle":"Porting an Existing Game","url":"docs/v0.5/getting-started/existing-game/#rbxlx-to-rojo","content":"There are ongoing efforts to make porting an existing game to Rojo more automatic. Currently, the most developed tool for this is rbxlx-to-rojo. "},{"title":"Remodel​","type":1,"pageTitle":"Porting an Existing Game","url":"docs/v0.5/getting-started/existing-game/#remodel","content":"Another option for porting an existing game is to use Remodel, which allows deep customization and would be suitable for porting a large, complex game. "},{"title":"Migrating Away from Rojo​","type":1,"pageTitle":"Porting an Existing Game","url":"docs/v0.5/getting-started/existing-game/#migrating-away-from-rojo","content":"Migrating away from Rojo is very simple: start editing your Roblox place directly instead of the files on the filesystem! Because everything in Rojo turns into a normal Roblox place or model, you aren't locked into Rojo if you decide to try it for a small part of your game. "},{"title":"Installation","type":0,"sectionRef":"#","url":"docs/v0.5/getting-started/installation/","content":"Installation There are two supported ways to install Rojo: VS CodeCLI If you use Visual Studio Code, you can install the Rojo VS Code extension, which allows for both halves of Rojo to work within Visual Studio Code, with a nifty UI to sync files and start/stop the Rojo server! info The VS Code extension does not add rojo to your system PATH. In order to use Rojo from the terminal, you'll need to install the CLI separately.","keywords":""},{"title":"Creating a New Game","type":0,"sectionRef":"#","url":"docs/v0.5/getting-started/new-game/","content":"","keywords":""},{"title":"Creating the Rojo Project​","type":1,"pageTitle":"Creating a New Game","url":"docs/v0.5/getting-started/new-game/#creating-the-rojo-project","content":"Rojo has a built-in command to initialize a new game project. VS CodeCLI Open a new empty folder in VS Code. Your editor should look like this: Open your VS Code Command Palette (ctrl+shift+P on Windows, cmd+shift+P on macOS) and type rojo init. Run the command that pops up: Once it succeeds, you should see a bunch of new files: These are all the files you need to get started with Rojo. "},{"title":"Building Your Place​","type":1,"pageTitle":"Creating a New Game","url":"docs/v0.5/getting-started/new-game/#building-your-place","content":"Now that we have a project, one thing we can do is build a Roblox place file for our project. This is a great way to get started with a project quickly with no fuss. VS CodeCLI Open your VS Code Command Palette and type rojo build. You'll be prompted to select a project, choose the default one. Rojo will create a file named build.rbxlx that contains your new game! If you open build.rbxlx in Roblox Studio now, you should see a baseplate, as well as code in services like ReplicatedStorage. "},{"title":"Live-Syncing into Studio​","type":1,"pageTitle":"Creating a New Game","url":"docs/v0.5/getting-started/new-game/#live-syncing-into-studio","content":"Building a place file is great for starting to work on a game, but for active iteration, you'll want something faster. In Roblox Studio, make sure the Rojo plugin is installed. If you need it, check out the installation guide to learn how to install it. To expose your project to the plugin, you'll need to start the live sync server. VS CodeCLI Open your VS Code Command Palette, type rojo serve, and choose the extension's command. You should see a small popup in the bottom right corner of your screen with a few details. Switch into Roblox Studio and press the Rojo plugin toolbar button. A panel should open:  Press Connect. If all went well, you should now be able to change files in your project directory and watch them sync into Roblox Studio in real time! You can also visit the URL printed by Rojo to access extra information about the running session. "},{"title":"Uploading Your Place​","type":1,"pageTitle":"Creating a New Game","url":"docs/v0.5/getting-started/new-game/#uploading-your-place","content":"Aimed at teams that want serious levels of automation, Rojo can upload places to Roblox.com automatically. You'll need an existing game on Roblox.com as well as the .ROBLOSECURITY cookie of an account that has write access to that game. warning It's recommended that you set up a Roblox account dedicated to deploying your game instead of your personal account in case your security cookie is compromised. Generating and publishing your game is as simple as: VS CodeCLI Uploading places is not yet supported in the Rojo VS Code Extension. You can publish your game using Roblox Studio or use the Rojo CLI instead. "},{"title":"Help!","type":0,"sectionRef":"#","url":"docs/v0.5/help/","content":"Help! Rojo is a fairly complex tool to adopt, but there's a community willing to help! The Roblox Open Source Community Discord currently hosts a Rojo support channel, #rojo, that is a great place to get help as problems come up. If you find anything that looks like a bug or have ideas for how to improve Rojo, feel free to file an issue on Rojo's GitHub issue tracker. Rojo's primary maintainer is also available on Twitter, @LPGhatguy.","keywords":""},{"title":"Fully vs Partially Managed Rojo","type":0,"sectionRef":"#","url":"docs/v0.5/reference/full-vs-partial/","content":"","keywords":""},{"title":"Fully Managed​","type":1,"pageTitle":"Fully vs Partially Managed Rojo","url":"docs/v0.5/reference/full-vs-partial/#fully-managed","content":"In a fully managed game project, Rojo controls every instance. A fully managed Rojo project can be built from scratch using rojo build. Fully managed projects are most practical for libraries, plugins, and simple games. Rojo's goal is to make it practical and easy for every project to be fully managed, but we're not quite there yet! "},{"title":"Pros​","type":1,"pageTitle":"Fully vs Partially Managed Rojo","url":"docs/v0.5/reference/full-vs-partial/#pros","content":"Fully reproducible builds from scratchEverything checked into version control "},{"title":"Cons​","type":1,"pageTitle":"Fully vs Partially Managed Rojo","url":"docs/v0.5/reference/full-vs-partial/#cons","content":"Without two-way sync, models have to be saved manually This can be done with the 'Save to File...' menu in Roblox StudioThis will be solved by Two-Way Sync (issue #164) Rojo can't manage everything yet Refs are currently broken (issue #142) "},{"title":"Partially Managed​","type":1,"pageTitle":"Fully vs Partially Managed Rojo","url":"docs/v0.5/reference/full-vs-partial/#partially-managed","content":"In a partially managed project, Rojo only handles a slice of the game. This could be as small as a couple scripts, or as large as everything except Workspace! The rest of the place's content can be versioned using Team Create or checked into source control. Partially managed projects are most practical for complicated games, or games that are migrating to use Rojo. "},{"title":"Pros​","type":1,"pageTitle":"Fully vs Partially Managed Rojo","url":"docs/v0.5/reference/full-vs-partial/#pros-1","content":"Easier to adopt graduallyIntegrates with Team Create "},{"title":"Cons​","type":1,"pageTitle":"Fully vs Partially Managed Rojo","url":"docs/v0.5/reference/full-vs-partial/#cons-1","content":"Not everything is in version control, which makes merges tougherRojo can't live-sync instances like Terrain, MeshPart, or CSG operations yet Will be fixed with plugin escalation (issue #169) "},{"title":"Rojo Alternatives","type":0,"sectionRef":"#","url":"docs/v0.5/rojo-alternatives/","content":"Rojo Alternatives There are a number of existing plugins for Roblox that move code from the filesystem into Roblox. Besides Rojo, you might consider: rbxmk by AnaminusRofresh by OsyrisRbxRefresh by OsyrisStudio Bridge by VockselElixir by VockselRbxSync by evaeraCodeSync by MemoryPenguinrbx-exteditor by MemoryPenguin So why did I build Rojo? Each of these tools solves what is essentially the same problem from a few different angles. The goal of Rojo is to take all of the lessons and ideas learned from these projects and build a tool that can solve this problem for good. Additionally: I think that this tool needs to be built in a compiled language without a runtime, for easy distribution and good performance.I think that the conventions promoted by other sync plugins (.module.lua for modules, as well a single sync point) are sub-optimal.I think that I have a good enough understanding of the problem to build something robust.I think that Rojo should be able to do more than just sync code.","keywords":""},{"title":"Project Format","type":0,"sectionRef":"#","url":"docs/v0.5/project-format/","content":"","keywords":""},{"title":"Project File​","type":1,"pageTitle":"Project Format","url":"docs/v0.5/project-format/#project-file","content":"Rojo projects are JSON files that have the .project.json extension. They have the following fields: name: A string indicating the name of the project. This name is used when building the project into a model or place file. Required tree: An Instance Description describing the root instance of the project. Required servePort: The port that rojo serve should listen on. Passing --port will override this setting. OptionalDefault is 34872 servePlaceIds: A list of place IDs that this project may be live-synced to. This feature can help prevent overwriting the wrong game with source from Rojo. OptionalDefault is null globIgnorePaths: A list of globs of paths to ignore. OptionalDefault is [] "},{"title":"Instance Description​","type":1,"pageTitle":"Project Format","url":"docs/v0.5/project-format/#instance-description","content":"Instance Descriptions correspond one-to-one with the actual Roblox Instances in the project. $className: The ClassName of the Instance being described. Required $path: The path on the filesystem to pull files from into the project. Optional if $className is specified.Paths are relative to the folder containing the project file. $properties: Properties to apply to the instance. Values should be Instance Property Values. Optional $ignoreUnknownInstances: Whether instances that Rojo doesn't know about should be deleted. OptionalDefault is false if $path is specified, otherwise true. All other fields in an Instance Description are turned into instances whose name is the key. These values should also be Instance Descriptions! "},{"title":"Instance Property Value​","type":1,"pageTitle":"Project Format","url":"docs/v0.5/project-format/#instance-property-value","content":"There are two kinds of property values on instances, implicit and explicit. In the vast majority of cases, you should be able to use implicit property values. To use them, just use a value that's the same shape as the type that the property has: &quot;MyPart&quot;: { &quot;$className&quot;: &quot;Part&quot;, &quot;$properties&quot;: { &quot;Size&quot;: [3, 5, 3], &quot;Color&quot;: [0.5, 0, 0.5], &quot;Anchored&quot;: true, &quot;Material&quot;: &quot;Granite&quot; } }  Vector3 and Color3 properties can just be arrays of numbers, as can types like Vector2, CFrame, and more! Enums can be set to a string containing the enum variant. Rojo will raise an error if the string isn't a valid variant for the enum. There are some cases where this syntax for assigning properties doesn't work. In these cases, Rojo requires you to use the explicit property syntax. Some reasons why you might need to use an explicit property: Using exotic property types like BinaryStringUsing properties added to Roblox recently that Rojo doesn't know about yet The shape of explicit property values is defined by the rbx-dom library, so it uses slightly different conventions than the rest of Rojo. Each value should be an object with the following required fields: Type: The type of property to represent. Supported types can be found here. Value: The value of the property. The shape of this field depends on which property type is being used. Vector3 and Color3 values are both represented as a list of numbers, while BinaryString expects a base64-encoded string, for example. Here's the same object, but with explicit properties: &quot;MyPart&quot;: { &quot;$className&quot;: &quot;Part&quot;, &quot;$properties&quot;: { &quot;Size&quot;: { &quot;Type&quot;: &quot;Vector3&quot;, &quot;Value&quot;: [3, 5, 3] }, &quot;Color&quot;: { &quot;Type&quot;: &quot;Color3&quot;, &quot;Value&quot;: [0.5, 0, 0.5] }, &quot;Anchored&quot;: { &quot;Type&quot;: &quot;Bool&quot;, &quot;Value&quot;: true }, &quot;Material&quot;: { &quot;Type&quot;: &quot;Enum&quot;, &quot;Value&quot;: 832 } } }  "},{"title":"Example Projects​","type":1,"pageTitle":"Project Format","url":"docs/v0.5/project-format/#example-projects","content":"This project bundles up everything in the src directory. It'd be suitable for making a plugin or model: { &quot;name&quot;: &quot;AwesomeLibrary&quot;, &quot;tree&quot;: { &quot;$path&quot;: &quot;src&quot; } }  This project describes the layout you might use if you were making the next hit simulator game, Sisyphus Simulator: { &quot;name&quot;: &quot;Sisyphus Simulator&quot;, &quot;globIgnorePaths&quot;: [&quot;**/*.spec.lua&quot;], &quot;tree&quot;: { &quot;$className&quot;: &quot;DataModel&quot;, &quot;HttpService&quot;: { &quot;$className&quot;: &quot;HttpService&quot;, &quot;$properties&quot;: { &quot;HttpEnabled&quot;: true } }, &quot;ReplicatedStorage&quot;: { &quot;$className&quot;: &quot;ReplicatedStorage&quot;, &quot;$path&quot;: &quot;src/ReplicatedStorage&quot; }, &quot;StarterPlayer&quot;: { &quot;$className&quot;: &quot;StarterPlayer&quot;, &quot;StarterPlayerScripts&quot;: { &quot;$className&quot;: &quot;StarterPlayerScripts&quot;, &quot;$path&quot;: &quot;src/StarterPlayerScripts&quot; } }, &quot;Workspace&quot;: { &quot;$className&quot;: &quot;Workspace&quot;, &quot;$properties&quot;: { &quot;Gravity&quot;: 67.3 }, &quot;Terrain&quot;: { &quot;$path&quot;: &quot;Terrain.rbxm&quot; } } } }  "},{"title":"Recomended Workflows","type":0,"sectionRef":"#","url":"docs/v0.5/workflows/","content":"","keywords":""},{"title":"Development Places​","type":1,"pageTitle":"Recomended Workflows","url":"docs/v0.5/workflows/#development-places","content":"Many Roblox developers collaborate using Team Create. While Team Create is great for collaborative building and newer developers, it is also prone to issues. What workflow you migrate to depends on how much of your game you would like Rojo to manage. If you just want to use Rojo to manage your game's scripts, and leave everything else managed by Team Create or a similar feature, that is called Partially Managed Rojo. If you want to manage your entire game with Rojo and reap all of its benefits like continuous deployment and hermetic builds, that is called Fully Managed Rojo. "},{"title":"Partially Managed Rojo​","type":1,"pageTitle":"Recomended Workflows","url":"docs/v0.5/workflows/#partially-managed-rojo","content":"Best practice is still being developed here, but it is generally recommended that each programmer on a project have their own place to work in. TODO "},{"title":"Fully Managed Rojo​","type":1,"pageTitle":"Recomended Workflows","url":"docs/v0.5/workflows/#fully-managed-rojo","content":"TODO "},{"title":"Introduction","type":0,"sectionRef":"#","url":"docs/v6/","content":"","keywords":""},{"title":"Why Rojo?​","type":1,"pageTitle":"Introduction","url":"docs/v6/#why-rojo","content":"Adding a tool like Rojo to your Roblox workflow can be daunting, but it comes with some key advantages. "},{"title":"Tools​","type":1,"pageTitle":"Introduction","url":"docs/v6/#tools","content":"There are decades of excellent tools available that operate on files. With Rojo, it's possible to take advantage of any of them! Popular tools that are tailored towards Roblox or Lua in general: Selene, a static analysis tool to help you write better LuaStyLua, a formatter that helps keep your code in a consistent styleWally, a package manager for Roblox projectsMoonwave, a documentation generator for Lua projects "},{"title":"Rojo at RDC 2019​","type":1,"pageTitle":"Introduction","url":"docs/v6/#rojo-at-rdc-2019","content":"Nathan Riemer (Kampfkarren) gave a talk at RDC 2019 talking about some of the benefits of using a tool like Rojo.  "},{"title":"External Text Editors​","type":1,"pageTitle":"Introduction","url":"docs/v6/#external-text-editors","content":"Rojo opens the door to use the absolute best text editors in the world and their rich plugin ecosystems. Some very popular editors include Visual Studio Code and Sublime Text. These advanced text editors have features like multi-cursor editing, go-to symbol, multi-file regex find and replace, bookmarks and much more. Many Rojo VS Code users also use extensions like: vscode-rbxluaRoblox Lua AutocompletesTabNine "},{"title":"Version Control​","type":1,"pageTitle":"Introduction","url":"docs/v6/#version-control","content":"By building your game (or just the scripts) as individual files on the filesystem, it becomes easy to start using professional-grade version control tools like Git and GitHub. Hundreds of thousands of companies and individual developers use Git to version their software projects. With Rojo, Roblox developers can take advantage of the best collaboration tool around. Using a repository hosting service like GitHub or GitLab brings powerful features to Roblox developers like code reviews and issue tracking that professional engineers can't live without. "},{"title":"TypeScript​","type":1,"pageTitle":"Introduction","url":"docs/v6/#typescript","content":"TypeScript enables static type safety, which helps prevent typos and adds unparalleled autocompletion. It also brings features like arrow functions, object destructuring, functional programming methods, and more! With Rojo, you can use roblox-ts to compile TypeScript to Lua and take advantage of a huge ecosystem of TypeScript tooling. It's also possible to use other languages that compile to Lua like MoonScript and Haxe. "},{"title":"Sync Details","type":0,"sectionRef":"#","url":"docs/v0.5/sync-details/","content":"","keywords":""},{"title":"Overview​","type":1,"pageTitle":"Sync Details","url":"docs/v0.5/sync-details/#overview","content":"Concept\tFile NameFolders\tany directory Server Scripts\t*.server.lua Client Scripts\t*.client.lua Module Scripts\t*.lua XML Models\t*.rbxmx Binary Models\t*.rbxm Localization Tables\t*.csv Plain Text\t*.txt JSON Modules\t*.json JSON Models\t*.model.json Projects\t*.project.json Meta Files\t*.meta.json "},{"title":"Limitations​","type":1,"pageTitle":"Sync Details","url":"docs/v0.5/sync-details/#limitations","content":"Not all property types can be synced by Rojo in real-time due to limitations of the Roblox Studio plugin API. In these cases, you can usually generate a place file and open it when you start working on a project. Some common cases you might hit are: Binary data (Terrain, CSG parts)MeshPart.MeshIdHttpService.HttpEnabled For a list of all property types that Rojo can reason about, both when live-syncing and when building place files, look at rbx-dom's type coverage chart. This limitation may be solved by issue #205 in the future. "},{"title":"Folders​","type":1,"pageTitle":"Sync Details","url":"docs/v0.5/sync-details/#folders","content":"Any directory on the filesystem will turn into a Folder instance with the same name. It is possible for a directory to contain certain files that change what the directory turns into: An init.lua, init.server.lua, or init.client.lua file, described in Scripts.An init.meta.json file that defines className, described in Meta Files.A default.project.json file, described in Projects. "},{"title":"Scripts​","type":1,"pageTitle":"Sync Details","url":"docs/v0.5/sync-details/#scripts","content":"Rojo transforms any files with the lua extension into the various script instances that Roblox has. Any file ending in .server.lua will turn into a Script instance.Any file ending in .client.lua will turn into a LocalScript instance.Any other .lua file will turn into a ModuleScript instance. Rojo reserves three special script names. These scripts change their parent directory into a script instead of a folder: init.server.lua will change its parent directory into a Script instance.init.client.lua will change its parent directory into a LocalScript instance.init.lua will change its parent directory into a ModuleScript instance. For example, these files:  Will turn into these instances in Roblox:  Only one &quot;init script&quot; can be present in the same folder. "},{"title":"Models​","type":1,"pageTitle":"Sync Details","url":"docs/v0.5/sync-details/#models","content":"Rojo supports both binary (.rbxm) and XML (.rbxmx) models generated by Roblox Studio or another tool. Support for rbxmx is very good, while support for rbxm is still very early, buggy, and lacking features. For a rundown of supported types, check out rbx-dom's type coverage chart. "},{"title":"Localization Tables​","type":1,"pageTitle":"Sync Details","url":"docs/v0.5/sync-details/#localization-tables","content":"Any file with the csv extension is transformed into a LocalizationTable instance. Rojo expects these files to follow the same format that Roblox does when importing and exporting localization information. An example CSV localization table is: Key,Source,Context,Example,es Ack,Ack!,,An exclamation of despair,¡Ay!  "},{"title":"Plain Text​","type":1,"pageTitle":"Sync Details","url":"docs/v0.5/sync-details/#plain-text","content":"Any file with the txt extension is transformed into a StringValue instance. This is useful for bringing in text data that can be read by scripts at runtime. "},{"title":"JSON Modules​","type":1,"pageTitle":"Sync Details","url":"docs/v0.5/sync-details/#json-modules","content":"Any file with the json extension that is not a JSON Model or a Project File "},{"title":"JSON Models​","type":1,"pageTitle":"Sync Details","url":"docs/v0.5/sync-details/#json-models","content":"Files ending in .model.json can be used to describe simple models. They're designed to be hand-written and are useful for instances like RemoteEvent. A JSON model describing a folder containing a Part and a RemoteEvent could be written as a file named My Cool Model.model.json with: { &quot;ClassName&quot;: &quot;Folder&quot;, &quot;Children&quot;: [ { &quot;Name&quot;: &quot;RootPart&quot;, &quot;ClassName&quot;: &quot;Part&quot;, &quot;Properties&quot;: { &quot;Size&quot;: { &quot;Type&quot;: &quot;Vector3&quot;, &quot;Value&quot;: [4, 4, 4] } } }, { &quot;Name&quot;: &quot;SendMoney&quot;, &quot;ClassName&quot;: &quot;RemoteEvent&quot; } ] }  It would turn into these instances:  "},{"title":"Projects​","type":1,"pageTitle":"Sync Details","url":"docs/v0.5/sync-details/#projects","content":"Starting in Rojo 6.0, project files can be included in other project files. This can be useful for reusing pieces between multiple project files. Projects that are intended to be included inside other projects should describe models, not places. If a directory contains a file named default.project.json, Rojo will use the contents of the project file instead of anything else in the directory. "},{"title":"Meta Files​","type":1,"pageTitle":"Sync Details","url":"docs/v0.5/sync-details/#meta-files","content":"New in Rojo 0.5 are meta files, named .meta.json. Meta files allow attaching extra Rojo data to models defined in other formats, like Roblox's rbxm and rbxmx model formats, or even Lua scripts. This can be used to set Rojo-specific settings like ignoreUnknownInstances, or can be used to set properties like Disabled on a script. Meta files can contain: className: Changes the className of a containing Folder into something else. Usable only in init.meta.json files properties: A map of properties to set on the instance, just like projects Usable on anything except .rbxmx, .rbxm, and .model.json files, which already have properties ignoreUnknownInstances: Works just like $ignoreUnknownInstances in project files "},{"title":"Meta Files to set Rojo metadata​","type":1,"pageTitle":"Sync Details","url":"docs/v0.5/sync-details/#meta-files-to-set-rojo-metadata","content":"Sometimes it's useful to apply properties like ignoreUnknownInstances on instances that are defined on the filesystem instead of within the project itself. If your project has hello.txt and there are instances underneath it that you want Rojo to ignore when live-syncing, you could create hello.meta.json with: { &quot;ignoreUnknownInstances&quot;: true }  "},{"title":"Meta Files for Disabled Scripts​","type":1,"pageTitle":"Sync Details","url":"docs/v0.5/sync-details/#meta-files-for-disabled-scripts","content":"Meta files can be used to set properties on Script instances, like Disabled. If your project has foo.server.lua and you want to make sure it would be disabled, you could create a foo.meta.json next to it with: { &quot;properties&quot;: { &quot;Disabled&quot;: true } }  "},{"title":"Meta Files for Tools​","type":1,"pageTitle":"Sync Details","url":"docs/v0.5/sync-details/#meta-files-for-tools","content":"If you wanted to represent a tool containing a script and a model for its handle, create a directory with an init.meta.json file in it: { &quot;className&quot;: &quot;Tool&quot;, &quot;properties&quot;: { &quot;Grip&quot;: [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1] } }  Instead of a Folder instance, you'll end up with a Tool instance with the Grip property set. "},{"title":"Porting an Existing Game","type":0,"sectionRef":"#","url":"docs/v6/getting-started/existing-game/","content":"","keywords":""},{"title":"Prepare Your Game​","type":1,"pageTitle":"Porting an Existing Game","url":"docs/v6/getting-started/existing-game/#prepare-your-game","content":"Not all Roblox idioms translate to the filesystem well. If possible, it's easiest to refactor your game slightly to reduce reliance on these before introducing Rojo. Even if you don't adopt Rojo, these ideas may still improve your game's structure! "},{"title":"Move Code into Fewer Places​","type":1,"pageTitle":"Porting an Existing Game","url":"docs/v6/getting-started/existing-game/#move-code-into-fewer-places","content":"Inside Roblox, it is common to have scripts stashed away in instances like GUI components, parts in the main scene, or in objects like Tools. Roblox games often also contain several copies of the same script, like old school lava bricks in an obstacle course, or the AI behavior for a zombie. Most software projects outside Roblox have a single location, like a folder named src, that all code goes into. By moving most of your code into services like ReplicatedStorage, ServerScriptService, and StarterPlayer, it becomes easier to find what you're looking for. Rewriting this code to use modern Roblox features like CollectionService can make it easier to understand, easier to work on, and more friendly to Rojo. "},{"title":"rbxlx-to-rojo​","type":1,"pageTitle":"Porting an Existing Game","url":"docs/v6/getting-started/existing-game/#rbxlx-to-rojo","content":"There are ongoing efforts to make porting an existing game to Rojo more automatic. Currently, the most developed tool for this is rbxlx-to-rojo. "},{"title":"Remodel​","type":1,"pageTitle":"Porting an Existing Game","url":"docs/v6/getting-started/existing-game/#remodel","content":"Another option for porting an existing game is to use Remodel, which allows deep customization and would be suitable for porting a large, complex game. "},{"title":"Migrating Away from Rojo​","type":1,"pageTitle":"Porting an Existing Game","url":"docs/v6/getting-started/existing-game/#migrating-away-from-rojo","content":"Migrating away from Rojo is very simple: start editing your Roblox place directly instead of the files on the filesystem! Because everything in Rojo turns into a normal Roblox place or model, you aren't locked into Rojo if you decide to try it for a small part of your game. "},{"title":"Installation","type":0,"sectionRef":"#","url":"docs/v6/getting-started/installation/","content":"Installation There are two supported ways to install Rojo: VS CodeCLI If you use Visual Studio Code, you can install the Rojo VS Code extension, which allows for both halves of Rojo to work within Visual Studio Code, with a nifty UI to sync files and start/stop the Rojo server! info The VS Code extension does not add rojo to your system PATH. In order to use Rojo from the terminal, you'll need to install the CLI separately.","keywords":""},{"title":"Help!","type":0,"sectionRef":"#","url":"docs/v6/help/","content":"Help! Rojo is a fairly complex tool to adopt, but there's a community willing to help! The Roblox Open Source Community Discord currently hosts a Rojo support channel, #rojo, that is a great place to get help as problems come up. If you find anything that looks like a bug or have ideas for how to improve Rojo, feel free to file an issue on Rojo's GitHub issue tracker. Rojo's primary maintainer is also available on Twitter, @LPGhatguy.","keywords":""},{"title":"Creating a New Game","type":0,"sectionRef":"#","url":"docs/v6/getting-started/new-game/","content":"","keywords":""},{"title":"Creating the Rojo Project​","type":1,"pageTitle":"Creating a New Game","url":"docs/v6/getting-started/new-game/#creating-the-rojo-project","content":"Rojo has a built-in command to initialize a new game project. VS CodeCLI Open a new empty folder in VS Code. Your editor should look like this: Open your VS Code Command Palette (ctrl+shift+P on Windows, cmd+shift+P on macOS) and type rojo init. Run the command that pops up: Once it succeeds, you should see a bunch of new files: These are all the files you need to get started with Rojo. "},{"title":"Building Your Place​","type":1,"pageTitle":"Creating a New Game","url":"docs/v6/getting-started/new-game/#building-your-place","content":"Now that we have a project, one thing we can do is build a Roblox place file for our project. This is a great way to get started with a project quickly with no fuss. VS CodeCLI Open your VS Code Command Palette and type rojo build. You'll be prompted to select a project, choose the default one. Rojo will create a file named build.rbxl that contains your new game! If you open build.rbxl in Roblox Studio now, you should see a baseplate, as well as code in services like ReplicatedStorage. "},{"title":"Live-Syncing into Studio​","type":1,"pageTitle":"Creating a New Game","url":"docs/v6/getting-started/new-game/#live-syncing-into-studio","content":"Building a place file is great for starting to work on a game, but for active iteration, you'll want something faster. In Roblox Studio, make sure the Rojo plugin is installed. If you need it, check out the installation guide to learn how to install it. To expose your project to the plugin, you'll need to start the live sync server. VS CodeCLI Open your VS Code Command Palette, type rojo serve, and choose the extension's command. You should see a small popup in the bottom right corner of your screen with a few details. Switch into Roblox Studio and press the Rojo plugin toolbar button. A panel should open:  Press Connect. If all went well, you should now be able to change files in your project directory and watch them sync into Roblox Studio in real time! You can also visit the URL printed by Rojo to access extra information about the running session. "},{"title":"Uploading Your Place​","type":1,"pageTitle":"Creating a New Game","url":"docs/v6/getting-started/new-game/#uploading-your-place","content":"Aimed at teams that want serious levels of automation, Rojo can upload places to Roblox.com automatically. You'll need an existing game on Roblox.com as well as the .ROBLOSECURITY cookie of an account that has write access to that game. warning It's recommended that you set up a Roblox account dedicated to deploying your game instead of your personal account in case your security cookie is compromised. Generating and publishing your game is as simple as: VS CodeCLI Uploading places is not yet supported in the Rojo VS Code Extension. You can publish your game using Roblox Studio or use the Rojo CLI instead. "},{"title":"Rojo Alternatives","type":0,"sectionRef":"#","url":"docs/v6/rojo-alternatives/","content":"Rojo Alternatives There are a number of existing plugins for Roblox that move code from the filesystem into Roblox. Besides Rojo, you might consider: rbxmk by AnaminusRofresh by OsyrisRbxRefresh by OsyrisStudio Bridge by VockselElixir by VockselRbxSync by evaeraCodeSync by MemoryPenguinrbx-exteditor by MemoryPenguin So why did I build Rojo? Each of these tools solves what is essentially the same problem from a few different angles. The goal of Rojo is to take all of the lessons and ideas learned from these projects and build a tool that can solve this problem for good. Additionally: I think that this tool needs to be built in a compiled language without a runtime, for easy distribution and good performance.I think that the conventions promoted by other sync plugins (.module.lua for modules, as well a single sync point) are sub-optimal.I think that I have a good enough understanding of the problem to build something robust.I think that Rojo should be able to do more than just sync code.","keywords":""},{"title":"Project Format","type":0,"sectionRef":"#","url":"docs/v6/project-format/","content":"","keywords":""},{"title":"Project File​","type":1,"pageTitle":"Project Format","url":"docs/v6/project-format/#project-file","content":"Rojo projects are JSON files that have the .project.json extension. They have the following fields: name: A string indicating the name of the project. This name is used when building the project into a model or place file. Required tree: An Instance Description describing the root instance of the project. Required servePort: The port that rojo serve should listen on. Passing --port will override this setting. OptionalDefault is 34872 servePlaceIds: A list of place IDs that this project may be live-synced to. This feature can help prevent overwriting the wrong game with source from Rojo. OptionalDefault is null globIgnorePaths: A list of globs of paths to ignore. OptionalDefault is [] "},{"title":"Instance Description​","type":1,"pageTitle":"Project Format","url":"docs/v6/project-format/#instance-description","content":"Instance Descriptions correspond one-to-one with the actual Roblox Instances in the project. $className: The ClassName of the Instance being described. Optional if $path is specified or if the instance is a Roblox service. $path: The path on the filesystem to pull files from into the project. Optional if $className is specified.Paths are relative to the folder containing the project file. $properties: Properties to apply to the instance. Values should be Instance Property Values. Optional $ignoreUnknownInstances: Whether instances that Rojo doesn't know about should be deleted. OptionalDefault is false if $path is specified, otherwise true. All other fields in an Instance Description are turned into instances whose name is the key. These values should also be Instance Descriptions! "},{"title":"Instance Property Value​","type":1,"pageTitle":"Project Format","url":"docs/v6/project-format/#instance-property-value","content":"There are two kinds of property values on instances, implicit and explicit. In the vast majority of cases, you should be able to use implicit property values. To use them, just use a value that's the same shape as the type that the property has: &quot;MyPart&quot;: { &quot;$className&quot;: &quot;Part&quot;, &quot;$properties&quot;: { &quot;Size&quot;: [3, 5, 3], &quot;Color&quot;: [0.5, 0, 0.5], &quot;Anchored&quot;: true, &quot;Material&quot;: &quot;Granite&quot; } }  Vector3 and Color3 properties can just be arrays of numbers, as can types like Vector2, CFrame, and more! Enums can be set to a string containing the enum variant. Rojo will raise an error if the string isn't a valid variant for the enum. There are some cases where this syntax for assigning properties doesn't work. In these cases, Rojo requires you to use the explicit property syntax. Some reasons why you might need to use an explicit property: Using exotic property types like BinaryStringUsing properties added to Roblox recently that Rojo doesn't know about yet The shape of explicit property values is defined by the rbx-dom library, so it uses slightly different conventions than the rest of Rojo. Each value should be an object with the following required fields: Type: The type of property to represent. Supported types can be found here. Value: The value of the property. The shape of this field depends on which property type is being used. Vector3 and Color3 values are both represented as a list of numbers, while BinaryString expects a base64-encoded string, for example. Here's the same object, but with explicit properties: &quot;MyPart&quot;: { &quot;$className&quot;: &quot;Part&quot;, &quot;$properties&quot;: { &quot;Size&quot;: { &quot;Type&quot;: &quot;Vector3&quot;, &quot;Value&quot;: [3, 5, 3] }, &quot;Color&quot;: { &quot;Type&quot;: &quot;Color3&quot;, &quot;Value&quot;: [0.5, 0, 0.5] }, &quot;Anchored&quot;: { &quot;Type&quot;: &quot;Bool&quot;, &quot;Value&quot;: true }, &quot;Material&quot;: { &quot;Type&quot;: &quot;Enum&quot;, &quot;Value&quot;: 832 } } }  "},{"title":"Example Projects​","type":1,"pageTitle":"Project Format","url":"docs/v6/project-format/#example-projects","content":"This project bundles up everything in the src directory. It'd be suitable for making a plugin or model: { &quot;name&quot;: &quot;AwesomeLibrary&quot;, &quot;tree&quot;: { &quot;$path&quot;: &quot;src&quot; } }  This project describes the layout you might use if you were making the next hit simulator game, Sisyphus Simulator: { &quot;name&quot;: &quot;Sisyphus Simulator&quot;, &quot;globIgnorePaths&quot;: [&quot;**/*.spec.lua&quot;], &quot;tree&quot;: { &quot;$className&quot;: &quot;DataModel&quot;, &quot;HttpService&quot;: { &quot;$className&quot;: &quot;HttpService&quot;, &quot;$properties&quot;: { &quot;HttpEnabled&quot;: true } }, &quot;ReplicatedStorage&quot;: { &quot;$className&quot;: &quot;ReplicatedStorage&quot;, &quot;$path&quot;: &quot;src/ReplicatedStorage&quot; }, &quot;StarterPlayer&quot;: { &quot;$className&quot;: &quot;StarterPlayer&quot;, &quot;StarterPlayerScripts&quot;: { &quot;$className&quot;: &quot;StarterPlayerScripts&quot;, &quot;$path&quot;: &quot;src/StarterPlayerScripts&quot; } }, &quot;Workspace&quot;: { &quot;$className&quot;: &quot;Workspace&quot;, &quot;$properties&quot;: { &quot;Gravity&quot;: 67.3 }, &quot;Terrain&quot;: { &quot;$path&quot;: &quot;Terrain.rbxm&quot; } } } }  "},{"title":"Recomended Workflows","type":0,"sectionRef":"#","url":"docs/v6/workflows/","content":"","keywords":""},{"title":"Development Places​","type":1,"pageTitle":"Recomended Workflows","url":"docs/v6/workflows/#development-places","content":"Many Roblox developers collaborate using Team Create. While Team Create is great for collaborative building and newer developers, it is also prone to issues. What workflow you migrate to depends on how much of your game you would like Rojo to manage. If you just want to use Rojo to manage your game's scripts, and leave everything else managed by Team Create or a similar feature, that is called Partially Managed Rojo. If you want to manage your entire game with Rojo and reap all of its benefits like continuous deployment and hermetic builds, that is called Fully Managed Rojo. "},{"title":"Partially Managed Rojo​","type":1,"pageTitle":"Recomended Workflows","url":"docs/v6/workflows/#partially-managed-rojo","content":"Best practice is still being developed here, but it is generally recommended that each programmer on a project have their own place to work in. TODO "},{"title":"Fully Managed Rojo​","type":1,"pageTitle":"Recomended Workflows","url":"docs/v6/workflows/#fully-managed-rojo","content":"TODO "},{"title":"Introduction","type":0,"sectionRef":"#","url":"docs/v7/","content":"","keywords":""},{"title":"Why Rojo?​","type":1,"pageTitle":"Introduction","url":"docs/v7/#why-rojo","content":"Adding a tool like Rojo to your Roblox workflow can be daunting, but it comes with some key advantages. "},{"title":"Tools​","type":1,"pageTitle":"Introduction","url":"docs/v7/#tools","content":"There are decades of excellent tools available that operate on files. With Rojo, it's possible to take advantage of any of them! Popular tools that are tailored towards Roblox or Lua in general: Selene, a static analysis tool to help you write better LuaStyLua, a formatter that helps keep your code in a consistent styleWally, a package manager for Roblox projectsMoonwave, a documentation generator for Lua projects "},{"title":"Rojo at RDC 2019​","type":1,"pageTitle":"Introduction","url":"docs/v7/#rojo-at-rdc-2019","content":"Nathan Riemer (Kampfkarren) gave a talk at RDC 2019 talking about some of the benefits of using a tool like Rojo.  "},{"title":"External Text Editors​","type":1,"pageTitle":"Introduction","url":"docs/v7/#external-text-editors","content":"Rojo opens the door to use the absolute best text editors in the world and their rich plugin ecosystems. Some very popular editors include Visual Studio Code and Sublime Text. These advanced text editors have features like multi-cursor editing, go-to symbol, multi-file regex find and replace, bookmarks and much more. Many Rojo VS Code users also use extensions like: vscode-rbxluaRoblox Lua AutocompletesTabNine "},{"title":"Version Control​","type":1,"pageTitle":"Introduction","url":"docs/v7/#version-control","content":"By building your game (or just the scripts) as individual files on the filesystem, it becomes easy to start using professional-grade version control tools like Git and GitHub. Hundreds of thousands of companies and individual developers use Git to version their software projects. With Rojo, Roblox developers can take advantage of the best collaboration tool around. Using a repository hosting service like GitHub or GitLab brings powerful features to Roblox developers like code reviews and issue tracking that professional engineers can't live without. "},{"title":"TypeScript​","type":1,"pageTitle":"Introduction","url":"docs/v7/#typescript","content":"TypeScript enables static type safety, which helps prevent typos and adds unparalleled autocompletion. It also brings features like arrow functions, object destructuring, functional programming methods, and more! With Rojo, you can use roblox-ts to compile TypeScript to Lua and take advantage of a huge ecosystem of TypeScript tooling. It's also possible to use other languages that compile to Lua like MoonScript and Haxe. "},{"title":"Sync Details","type":0,"sectionRef":"#","url":"docs/v6/sync-details/","content":"","keywords":""},{"title":"Overview​","type":1,"pageTitle":"Sync Details","url":"docs/v6/sync-details/#overview","content":"Concept\tFile NameFolders\tany directory Server Scripts\t*.server.lua Client Scripts\t*.client.lua Module Scripts\t*.lua XML Models\t*.rbxmx Binary Models\t*.rbxm Localization Tables\t*.csv Plain Text\t*.txt JSON Modules\t*.json JSON Models\t*.model.json Projects\t*.project.json Meta Files\t*.meta.json "},{"title":"Limitations​","type":1,"pageTitle":"Sync Details","url":"docs/v6/sync-details/#limitations","content":"Not all property types can be synced by Rojo in real-time due to limitations of the Roblox Studio plugin API. In these cases, you can usually generate a place file and open it when you start working on a project. Some common cases you might hit are: Binary data (Terrain, CSG parts)MeshPart.MeshIdHttpService.HttpEnabled For a list of all property types that Rojo can reason about, both when live-syncing and when building place files, look at rbx-dom's type coverage chart. This limitation may be solved by issue #205 in the future. "},{"title":"Folders​","type":1,"pageTitle":"Sync Details","url":"docs/v6/sync-details/#folders","content":"Any directory on the filesystem will turn into a Folder instance with the same name. It is possible for a directory to contain certain files that change what the directory turns into: An init.lua, init.server.lua, or init.client.lua file, described in Scripts.An init.meta.json file that defines className, described in Meta Files.A default.project.json file, described in Projects. "},{"title":"Scripts​","type":1,"pageTitle":"Sync Details","url":"docs/v6/sync-details/#scripts","content":"Rojo transforms any files with the lua extension into the various script instances that Roblox has. Any file ending in .server.lua will turn into a Script instance.Any file ending in .client.lua will turn into a LocalScript instance.Any other .lua file will turn into a ModuleScript instance. Rojo reserves three special script names. These scripts change their parent directory into a script instead of a folder: init.server.lua will change its parent directory into a Script instance.init.client.lua will change its parent directory into a LocalScript instance.init.lua will change its parent directory into a ModuleScript instance. For example, these files:  Will turn into these instances in Roblox:  Only one &quot;init script&quot; can be present in the same folder. "},{"title":"Models​","type":1,"pageTitle":"Sync Details","url":"docs/v6/sync-details/#models","content":"Rojo supports both binary (.rbxm) and XML (.rbxmx) models generated by Roblox Studio or another tool. Support for rbxmx is very good, while support for rbxm is still very early, buggy, and lacking features. For a rundown of supported types, check out rbx-dom's type coverage chart. "},{"title":"Localization Tables​","type":1,"pageTitle":"Sync Details","url":"docs/v6/sync-details/#localization-tables","content":"Any file with the csv extension is transformed into a LocalizationTable instance. Rojo expects these files to follow the same format that Roblox does when importing and exporting localization information. An example CSV localization table is: Key,Source,Context,Example,es Ack,Ack!,,An exclamation of despair,¡Ay!  "},{"title":"Plain Text​","type":1,"pageTitle":"Sync Details","url":"docs/v6/sync-details/#plain-text","content":"Any file with the txt extension is transformed into a StringValue instance. This is useful for bringing in text data that can be read by scripts at runtime. "},{"title":"JSON Modules​","type":1,"pageTitle":"Sync Details","url":"docs/v6/sync-details/#json-modules","content":"Any file with the json extension that is not a JSON Model or a Project File "},{"title":"JSON Models​","type":1,"pageTitle":"Sync Details","url":"docs/v6/sync-details/#json-models","content":"Files ending in .model.json can be used to describe simple models. They're designed to be hand-written and are useful for instances like RemoteEvent. A JSON model describing a folder containing a Part and a RemoteEvent could be written as a file named My Cool Model.model.json with: { &quot;ClassName&quot;: &quot;Folder&quot;, &quot;Children&quot;: [ { &quot;Name&quot;: &quot;RootPart&quot;, &quot;ClassName&quot;: &quot;Part&quot;, &quot;Properties&quot;: { &quot;Size&quot;: { &quot;Type&quot;: &quot;Vector3&quot;, &quot;Value&quot;: [4, 4, 4] } } }, { &quot;Name&quot;: &quot;SendMoney&quot;, &quot;ClassName&quot;: &quot;RemoteEvent&quot; } ] }  It would turn into these instances:  "},{"title":"Projects​","type":1,"pageTitle":"Sync Details","url":"docs/v6/sync-details/#projects","content":"Starting in Rojo 6.0, project files can be included in other project files. This can be useful for reusing pieces between multiple project files. Projects that are intended to be included inside other projects should describe models, not places. If a directory contains a file named default.project.json, Rojo will use the contents of the project file instead of anything else in the directory. "},{"title":"Meta Files​","type":1,"pageTitle":"Sync Details","url":"docs/v6/sync-details/#meta-files","content":"New in Rojo 0.5 are meta files, named .meta.json. Meta files allow attaching extra Rojo data to models defined in other formats, like Roblox's rbxm and rbxmx model formats, or even Lua scripts. This can be used to set Rojo-specific settings like ignoreUnknownInstances, or can be used to set properties like Disabled on a script. Meta files can contain: className: Changes the className of a containing Folder into something else. Usable only in init.meta.json files properties: A map of properties to set on the instance, just like projects Usable on anything except .rbxmx, .rbxm, and .model.json files, which already have properties ignoreUnknownInstances: Works just like $ignoreUnknownInstances in project files "},{"title":"Meta Files to set Rojo metadata​","type":1,"pageTitle":"Sync Details","url":"docs/v6/sync-details/#meta-files-to-set-rojo-metadata","content":"Sometimes it's useful to apply properties like ignoreUnknownInstances on instances that are defined on the filesystem instead of within the project itself. If your project has hello.txt and there are instances underneath it that you want Rojo to ignore when live-syncing, you could create hello.meta.json with: { &quot;ignoreUnknownInstances&quot;: true }  "},{"title":"Meta Files for Disabled Scripts​","type":1,"pageTitle":"Sync Details","url":"docs/v6/sync-details/#meta-files-for-disabled-scripts","content":"Meta files can be used to set properties on Script instances, like Disabled. If your project has foo.server.lua and you want to make sure it would be disabled, you could create a foo.meta.json next to it with: { &quot;properties&quot;: { &quot;Disabled&quot;: true } }  "},{"title":"Meta Files for Tools​","type":1,"pageTitle":"Sync Details","url":"docs/v6/sync-details/#meta-files-for-tools","content":"If you wanted to represent a tool containing a script and a model for its handle, create a directory with an init.meta.json file in it: { &quot;className&quot;: &quot;Tool&quot;, &quot;properties&quot;: { &quot;Grip&quot;: [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1] } }  Instead of a Folder instance, you'll end up with a Tool instance with the Grip property set. "},{"title":"Installation","type":0,"sectionRef":"#","url":"docs/v7/getting-started/installation/","content":"Installation There are two supported ways to install Rojo: VS CodeCLI If you use Visual Studio Code, you can install the Rojo VS Code extension, which allows for both halves of Rojo to work within Visual Studio Code, with a nifty UI to sync files and start/stop the Rojo server! info The VS Code extension does not add rojo to your system PATH. In order to use Rojo from the terminal, you'll need to install the CLI separately.","keywords":""},{"title":"Porting an Existing Game","type":0,"sectionRef":"#","url":"docs/v7/getting-started/existing-game/","content":"","keywords":""},{"title":"Prepare Your Game​","type":1,"pageTitle":"Porting an Existing Game","url":"docs/v7/getting-started/existing-game/#prepare-your-game","content":"Not all Roblox idioms translate to the filesystem well. If possible, it's easiest to refactor your game slightly to reduce reliance on these before introducing Rojo. Even if you don't adopt Rojo, these ideas may still improve your game's structure! "},{"title":"Move Code into Fewer Places​","type":1,"pageTitle":"Porting an Existing Game","url":"docs/v7/getting-started/existing-game/#move-code-into-fewer-places","content":"Inside Roblox, it is common to have scripts stashed away in instances like GUI components, parts in the main scene, or in objects like Tools. Roblox games often also contain several copies of the same script, like old school lava bricks in an obstacle course, or the AI behavior for a zombie. Most software projects outside Roblox have a single location, like a folder named src, that all code goes into. By moving most of your code into services like ReplicatedStorage, ServerScriptService, and StarterPlayer, it becomes easier to find what you're looking for. Rewriting this code to use modern Roblox features like CollectionService can make it easier to understand, easier to work on, and more friendly to Rojo. "},{"title":"rbxlx-to-rojo​","type":1,"pageTitle":"Porting an Existing Game","url":"docs/v7/getting-started/existing-game/#rbxlx-to-rojo","content":"There are ongoing efforts to make porting an existing game to Rojo more automatic. Currently, the most developed tool for this is rbxlx-to-rojo. "},{"title":"Remodel​","type":1,"pageTitle":"Porting an Existing Game","url":"docs/v7/getting-started/existing-game/#remodel","content":"Another option for porting an existing game is to use Remodel, which allows deep customization and would be suitable for porting a large, complex game. "},{"title":"Migrating Away from Rojo​","type":1,"pageTitle":"Porting an Existing Game","url":"docs/v7/getting-started/existing-game/#migrating-away-from-rojo","content":"Migrating away from Rojo is very simple: start editing your Roblox place directly instead of the files on the filesystem! Because everything in Rojo turns into a normal Roblox place or model, you aren't locked into Rojo if you decide to try it for a small part of your game. "},{"title":"Help!","type":0,"sectionRef":"#","url":"docs/v7/help/","content":"Help! Rojo is a fairly complex tool to adopt, but there's a community willing to help! The Roblox Open Source Community Discord currently hosts a Rojo support channel, #rojo, that is a great place to get help as problems come up. If you find anything that looks like a bug or have ideas for how to improve Rojo, feel free to file an issue on Rojo's GitHub issue tracker. Rojo's primary maintainer is also available on Twitter, @LPGhatguy.","keywords":""},{"title":"Creating a New Game","type":0,"sectionRef":"#","url":"docs/v7/getting-started/new-game/","content":"","keywords":""},{"title":"Creating the Rojo Project​","type":1,"pageTitle":"Creating a New Game","url":"docs/v7/getting-started/new-game/#creating-the-rojo-project","content":"Rojo has a built-in command to initialize a new game project. VS CodeCLI Open a new empty folder in VS Code. Your editor should look like this: Open your VS Code Command Palette (ctrl+shift+P on Windows, cmd+shift+P on macOS) and type rojo init. Run the command that pops up: Once it succeeds, you should see a bunch of new files: These are all the files you need to get started with Rojo. "},{"title":"Building Your Place​","type":1,"pageTitle":"Creating a New Game","url":"docs/v7/getting-started/new-game/#building-your-place","content":"Now that we have a project, one thing we can do is build a Roblox place file for our project. This is a great way to get started with a project quickly with no fuss. VS CodeCLI Open your VS Code Command Palette and type rojo build. You'll be prompted to select a project, choose the default one. Rojo will create a file named build.rbxlx that contains your new game! If you open build.rbxlx in Roblox Studio now, you should see a baseplate, as well as code in services like ReplicatedStorage. "},{"title":"Live-Syncing into Studio​","type":1,"pageTitle":"Creating a New Game","url":"docs/v7/getting-started/new-game/#live-syncing-into-studio","content":"Building a place file is great for starting to work on a game, but for active iteration, you'll want something faster. In Roblox Studio, make sure the Rojo plugin is installed. If you need it, check out the installation guide to learn how to install it. To expose your project to the plugin, you'll need to start the live sync server. VS CodeCLI Open your VS Code Command Palette, type rojo serve, and choose the extension's command. You should see a small popup in the bottom right corner of your screen with a few details. Switch into Roblox Studio and press the Rojo plugin toolbar button. A panel should open:  Press Connect. If all went well, you should now be able to change files in your project directory and watch them sync into Roblox Studio in real time! You can also visit the URL printed by Rojo to access extra information about the running session. "},{"title":"Uploading Your Place​","type":1,"pageTitle":"Creating a New Game","url":"docs/v7/getting-started/new-game/#uploading-your-place","content":"Aimed at teams that want serious levels of automation, Rojo can upload places to Roblox.com automatically. You'll need an existing game on Roblox.com as well as the .ROBLOSECURITY cookie of an account that has write access to that game. warning It's recommended that you set up a Roblox account dedicated to deploying your game instead of your personal account in case your security cookie is compromised. Generating and publishing your game is as simple as: VS CodeCLI Uploading places is not yet supported in the Rojo VS Code Extension. You can publish your game using Roblox Studio or use the Rojo CLI instead. "},{"title":"Project Format","type":0,"sectionRef":"#","url":"docs/v7/project-format/","content":"","keywords":""},{"title":"Project File​","type":1,"pageTitle":"Project Format","url":"docs/v7/project-format/#project-file","content":"Rojo projects are JSON files that have the .project.json extension. They have the following fields: name: A string indicating the name of the project. This name is used when building the project into a model or place file. Required tree: An Instance Description describing the root instance of the project. Required servePort: The port that rojo serve should listen on. Passing --port will override this setting. OptionalDefault is 34872 servePlaceIds: A list of place IDs that this project may be live-synced to. This feature can help prevent overwriting the wrong game with source from Rojo. OptionalDefault is null globIgnorePaths: A list of globs of paths to ignore. OptionalDefault is [] "},{"title":"Instance Description​","type":1,"pageTitle":"Project Format","url":"docs/v7/project-format/#instance-description","content":"Instance Descriptions correspond one-to-one with the actual Roblox Instances in the project. $className: The ClassName of the Instance being described. Optional if $path is specified or if the instance is a Roblox service. $path: The path on the filesystem to pull files from into the project. Optional if $className is specified.Paths are relative to the folder containing the project file. $properties: Properties to apply to the instance. Values should be Instance Property Values. Optional $ignoreUnknownInstances: Whether instances that Rojo doesn't know about should be deleted. OptionalDefault is false if $path is specified, otherwise true. All other fields in an Instance Description are turned into instances whose name is the key. These values should also be Instance Descriptions! "},{"title":"Instance Property Value​","type":1,"pageTitle":"Project Format","url":"docs/v7/project-format/#instance-property-value","content":"There are two kinds of property values on instances, implicit and explicit. An implicit value uses Rojo's knowledge of Roblox's API to infer the correct type, while an explicit value specifies the type directly. When a value is specified implicitly, Rojo uses the class name and property name to validate the value. That is, the format of an implicit value must be correct for the type corresponding to the class and property. For example, the Anchored property of the Part class is known by Rojo to be of the Bool type, so the implicit value must be a boolean: { &quot;$className&quot;: &quot;Part&quot;, &quot;$properties&quot;: { &quot;Anchored&quot;: true, } }  Conversely, an explicit value specifies the type of the value directly. An explicit value is an object with one field, where: The key of the field is the type of property to represent.The value of the field is the value of the property, in the format of the specified type. For example, the Anchored property specified explicitly: { &quot;$className&quot;: &quot;Part&quot;, &quot;$properties&quot;: { &quot;Anchored&quot;: { &quot;Bool&quot;: true }, } }  For explicit values, Rojo does not validate the type against Roblox's API. For example, the type of the Anchored property could be overridden to be a string instead: { &quot;$className&quot;: &quot;Part&quot;, &quot;$properties&quot;: { &quot;Anchored&quot;: { &quot;String&quot;: &quot;Hello, world!&quot; }, } }  Explicit values are necessary for properties that Rojo does not know about. This includes properties that have been recently added to Roblox's API, and certain internal properties that aren't described by Roblox's API at all. The Properties page describes the formats of each type in detail. "},{"title":"Example Projects​","type":1,"pageTitle":"Project Format","url":"docs/v7/project-format/#example-projects","content":"This project bundles up everything in the src directory. It'd be suitable for making a plugin or model: { &quot;name&quot;: &quot;AwesomeLibrary&quot;, &quot;tree&quot;: { &quot;$path&quot;: &quot;src&quot; } }  This project describes the layout you might use if you were making the next hit simulator game, Sisyphus Simulator: { &quot;name&quot;: &quot;Sisyphus Simulator&quot;, &quot;globIgnorePaths&quot;: [&quot;**/*.spec.lua&quot;], &quot;tree&quot;: { &quot;$className&quot;: &quot;DataModel&quot;, &quot;HttpService&quot;: { &quot;$className&quot;: &quot;HttpService&quot;, &quot;$properties&quot;: { &quot;HttpEnabled&quot;: true } }, &quot;ReplicatedStorage&quot;: { &quot;$className&quot;: &quot;ReplicatedStorage&quot;, &quot;$path&quot;: &quot;src/ReplicatedStorage&quot; }, &quot;StarterPlayer&quot;: { &quot;$className&quot;: &quot;StarterPlayer&quot;, &quot;StarterPlayerScripts&quot;: { &quot;$className&quot;: &quot;StarterPlayerScripts&quot;, &quot;$path&quot;: &quot;src/StarterPlayerScripts&quot; } }, &quot;Workspace&quot;: { &quot;$className&quot;: &quot;Workspace&quot;, &quot;$properties&quot;: { &quot;Gravity&quot;: 67.3 }, &quot;Terrain&quot;: { &quot;$path&quot;: &quot;Terrain.rbxm&quot; } } } }  "},{"title":"Rojo Alternatives","type":0,"sectionRef":"#","url":"docs/v7/rojo-alternatives/","content":"Rojo Alternatives There are a number of existing plugins for Roblox that move code from the filesystem into Roblox. Besides Rojo, you might consider: rbxmk by AnaminusRofresh by OsyrisRbxRefresh by OsyrisStudio Bridge by VockselElixir by VockselRbxSync by evaeraCodeSync by MemoryPenguinrbx-exteditor by MemoryPenguin So why did I build Rojo? Each of these tools solves what is essentially the same problem from a few different angles. The goal of Rojo is to take all of the lessons and ideas learned from these projects and build a tool that can solve this problem for good. Additionally: I think that this tool needs to be built in a compiled language without a runtime, for easy distribution and good performance.I think that the conventions promoted by other sync plugins (.module.lua for modules, as well a single sync point) are sub-optimal.I think that I have a good enough understanding of the problem to build something robust.I think that Rojo should be able to do more than just sync code.","keywords":""},{"title":"Sync Details","type":0,"sectionRef":"#","url":"docs/v7/sync-details/","content":"","keywords":""},{"title":"Overview​","type":1,"pageTitle":"Sync Details","url":"docs/v7/sync-details/#overview","content":"Concept\tFile NameFolders\tany directory Server Scripts\t*.server.lua Client Scripts\t*.client.lua Module Scripts\t*.lua XML Models\t*.rbxmx Binary Models\t*.rbxm Localization Tables\t*.csv Plain Text\t*.txt JSON Modules\t*.json JSON Models\t*.model.json Projects\t*.project.json Meta Files\t*.meta.json "},{"title":"Limitations​","type":1,"pageTitle":"Sync Details","url":"docs/v7/sync-details/#limitations","content":"Not all property types can be synced by Rojo in real-time due to limitations of the Roblox Studio plugin API. In these cases, you can usually generate a place file and open it when you start working on a project. Some common cases you might hit are: Binary data (Terrain, CSG parts)MeshPart.MeshIdHttpService.HttpEnabled For a list of all property types that Rojo can reason about, both when live-syncing and when building place files, look at rbx-dom's type coverage chart. This limitation may be solved by issue #205 in the future. "},{"title":"Folders​","type":1,"pageTitle":"Sync Details","url":"docs/v7/sync-details/#folders","content":"Any directory on the filesystem will turn into a Folder instance with the same name. It is possible for a directory to contain certain files that change what the directory turns into: An init.lua, init.server.lua, or init.client.lua file, described in Scripts.An init.meta.json file that defines className, described in Meta Files.A default.project.json file, described in Projects. "},{"title":"Scripts​","type":1,"pageTitle":"Sync Details","url":"docs/v7/sync-details/#scripts","content":"Rojo transforms any files with the lua extension into the various script instances that Roblox has. Any file ending in .server.lua will turn into a Script instance.Any file ending in .client.lua will turn into a LocalScript instance.Any other .lua file will turn into a ModuleScript instance. Rojo reserves three special script names. These scripts change their parent directory into a script instead of a folder: init.server.lua will change its parent directory into a Script instance.init.client.lua will change its parent directory into a LocalScript instance.init.lua will change its parent directory into a ModuleScript instance. For example, these files:  Will turn into these instances in Roblox:  Only one &quot;init script&quot; can be present in the same folder. "},{"title":"Models​","type":1,"pageTitle":"Sync Details","url":"docs/v7/sync-details/#models","content":"Rojo supports both binary (.rbxm) and XML (.rbxmx) models generated by Roblox Studio or another tool. Support for rbxmx is very good, while support for rbxm is still very early, buggy, and lacking features. For a rundown of supported types, check out rbx-dom's type coverage chart. "},{"title":"Localization Tables​","type":1,"pageTitle":"Sync Details","url":"docs/v7/sync-details/#localization-tables","content":"Any file with the csv extension is transformed into a LocalizationTable instance. Rojo expects these files to follow the same format that Roblox does when importing and exporting localization information. An example CSV localization table is: Key,Source,Context,Example,es Ack,Ack!,,An exclamation of despair,¡Ay!  "},{"title":"Plain Text​","type":1,"pageTitle":"Sync Details","url":"docs/v7/sync-details/#plain-text","content":"Any file with the txt extension is transformed into a StringValue instance. This is useful for bringing in text data that can be read by scripts at runtime. "},{"title":"JSON Modules​","type":1,"pageTitle":"Sync Details","url":"docs/v7/sync-details/#json-modules","content":"Any file with the json extension that is not a JSON Model or a Project File "},{"title":"JSON Models​","type":1,"pageTitle":"Sync Details","url":"docs/v7/sync-details/#json-models","content":"Files ending in .model.json can be used to describe simple models. They're designed to be hand-written and are useful for instances like RemoteEvent. A JSON model describing a folder containing a Part and a RemoteEvent could be written as a file named My Cool Model.model.json with: { &quot;ClassName&quot;: &quot;Folder&quot;, &quot;Children&quot;: [ { &quot;Name&quot;: &quot;RootPart&quot;, &quot;ClassName&quot;: &quot;Part&quot;, &quot;Properties&quot;: { &quot;Size&quot;: [4, 4, 4] } }, { &quot;Name&quot;: &quot;SendMoney&quot;, &quot;ClassName&quot;: &quot;RemoteEvent&quot; } ] }  It would turn into these instances:  "},{"title":"Projects​","type":1,"pageTitle":"Sync Details","url":"docs/v7/sync-details/#projects","content":"Starting in Rojo 6.0, project files can be included in other project files. This can be useful for reusing pieces between multiple project files. Projects that are intended to be included inside other projects should describe models, not places. If a directory contains a file named default.project.json, Rojo will use the contents of the project file instead of anything else in the directory. "},{"title":"Meta Files​","type":1,"pageTitle":"Sync Details","url":"docs/v7/sync-details/#meta-files","content":"New in Rojo 0.5 are meta files, named .meta.json. Meta files allow attaching extra Rojo data to models defined in other formats, like Roblox's rbxm and rbxmx model formats, or even Lua scripts. This can be used to set Rojo-specific settings like ignoreUnknownInstances, or can be used to set properties like Disabled on a script. Meta files can contain: className: Changes the className of a containing Folder into something else. Usable only in init.meta.json files properties: A map of properties to set on the instance, just like projects Usable on anything except .rbxmx, .rbxm, and .model.json files, which already have properties ignoreUnknownInstances: Works just like $ignoreUnknownInstances in project files "},{"title":"Meta Files to set Rojo metadata​","type":1,"pageTitle":"Sync Details","url":"docs/v7/sync-details/#meta-files-to-set-rojo-metadata","content":"Sometimes it's useful to apply properties like ignoreUnknownInstances on instances that are defined on the filesystem instead of within the project itself. If your project has hello.txt and there are instances underneath it that you want Rojo to ignore when live-syncing, you could create hello.meta.json with: { &quot;ignoreUnknownInstances&quot;: true }  "},{"title":"Meta Files for Disabled Scripts​","type":1,"pageTitle":"Sync Details","url":"docs/v7/sync-details/#meta-files-for-disabled-scripts","content":"Meta files can be used to set properties on Script instances, like Disabled. If your project has foo.server.lua and you want to make sure it would be disabled, you could create a foo.meta.json next to it with: { &quot;properties&quot;: { &quot;Disabled&quot;: true } }  "},{"title":"Meta Files for Tools​","type":1,"pageTitle":"Sync Details","url":"docs/v7/sync-details/#meta-files-for-tools","content":"If you wanted to represent a tool containing a script and a model for its handle, create a directory with an init.meta.json file in it: { &quot;className&quot;: &quot;Tool&quot;, &quot;properties&quot;: { &quot;Grip&quot;: [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1] } }  Instead of a Folder instance, you'll end up with a Tool instance with the Grip property set. "},{"title":"Properties","type":0,"sectionRef":"#","url":"docs/v7/properties/","content":"","keywords":""},{"title":"Property Type Support​","type":1,"pageTitle":"Properties","url":"docs/v7/properties/#property-type-support","content":"Property Type\tExample Property\tBuild\tLive Sync\tProject FilesAttributes\tInstance.Attributes\t✔\t✔\t✔ Axes\tArcHandles.Axes\t✔\t✔\t✔ BinaryString\tTerrain.MaterialColors\t✔\t❌\t✔ Bool\tPart.Anchored\t✔\t✔\t✔ BrickColor\tPart.BrickColor\t✔\t✔\t✔ CFrame\tCamera.CFrame\t✔\t✔\t✔ Color3\tLighting.Ambient\t✔\t✔\t✔ Color3uint8\tPart.BrickColor\t✔\t✔\t✔ ColorSequence\tBeam.Color\t✔\t✔\t✔ Content\tDecal.Texture\t✔\t✔\t✔ Enum\tPart.Shape\t✔\t✔\t✔ Faces\tHandles.Faces\t✔\t✔\t✔ Float32\tPlayers.RespawnTime\t✔\t✔\t✔ Float64\tSound.PlaybackLoudness\t✔\t✔\t✔ Int32\tFrame.ZIndex\t✔\t✔\t✔ Int64\tPlayer.UserId\t✔\t✔\t✔ NumberRange\tParticleEmitter.Lifetime\t✔\t✔\t✔ NumberSequence\tBeam.Transparency\t✔\t✔\t✔ OptionalCoordinateFrame\tModel.WorldPivotData\t✔\t❌\t✔ PhysicalProperties\tPart.CustomPhysicalProperties\t✔\t✔\t✔ ProtectedString\tModuleScript.Source\t✔\t✔\t✔ Ray\tRayValue.Value\t✔\t✔\t✔ Rect\tImageButton.SliceCenter\t✔\t✔\t✔ Ref\tModel.PrimaryPart\t✔\t✔\t❌ Region3\tN/A\t✔\t✔\t❌ Region3int16\tTerrain.MaxExtents\t✔\t✔\t❌ SharedString\tN/A\t✔\t✔\t❌ String\tInstance.Name\t✔\t✔\t✔ Tags\tInstance.Tags\t✔\t✔\t✔ UDim\tUIListLayout.Padding\t✔\t✔\t✔ UDim2\tFrame.Size\t✔\t✔\t✔ Vector2\tImageLabel.ImageRectSize\t✔\t✔\t✔ Vector2int16\tN/A\t✔\t✔\t✔ Vector3\tPart.Size\t✔\t✔\t✔ Vector3int16\tTerrainRegion.ExtentsMax\t✔\t✔\t✔ QDir\tStudio.Auto-Save Path\t❌\t❌\t❌ QFont\tStudio.Font\t❌\t❌\t❌ "},{"title":"Properties in Project Files​","type":1,"pageTitle":"Properties","url":"docs/v7/properties/#properties-in-project-files","content":"Many types have an implicit and explicit format. The Project format page decribes these formats in more detail. "},{"title":"Attributes​","type":1,"pageTitle":"Properties","url":"docs/v7/properties/#attributes","content":"Rojo defines the &quot;Attributes&quot; property on any instance to have the Attributes type, allowing it to be specified implicitly. For both implicit and explicit values, the format is an object where each field represents an attribute, where the key is the name of the attribute, and the value must be an explicit value. { &quot;$properties&quot;: { &quot;Attributes&quot;: { &quot;Foo&quot;: {&quot;Bool&quot;: true}, &quot;Bar&quot;: {&quot;Vector3&quot;: [1.0, 2.0, 3.0]}, }, &quot;AttributesSerialized&quot;: { &quot;Attributes&quot;: { &quot;Foo&quot;: {&quot;Bool&quot;: true}, &quot;Bar&quot;: {&quot;Vector3&quot;: [1.0, 2.0, 3.0]}, } } } }  The following types are supported for attribute values: BoolBrickColorColor3ColorSequenceFloat64NumberRangeNumberSequenceRectStringUDimUDim2Vector2Vector3 "},{"title":"Axes​","type":1,"pageTitle":"Properties","url":"docs/v7/properties/#axes","content":"The Axes type cannot be specified implicitly. For explicit values, the format is a list of strings, each of which may be either &quot;X&quot;, &quot;Y&quot;, or &quot;Z&quot;. Each string sets the corresponding component. { &quot;$properties&quot;: { &quot;ExplicitExample1&quot;: {&quot;Axes&quot;: [&quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;]}, &quot;ExplicitExample2&quot;: {&quot;Axes&quot;: [&quot;X&quot;, &quot;Z&quot;]}, &quot;ExplicitExample3&quot;: {&quot;Axes&quot;: []} } }  "},{"title":"BinaryString​","type":1,"pageTitle":"Properties","url":"docs/v7/properties/#binarystring","content":"The BinaryString type cannot be specified implicitly. For explicit values, the format is a base64-encoded string. { &quot;$properties&quot;: { &quot;ExplicitExample&quot;: {&quot;BinaryString&quot;: &quot;SGVsbG8sIHdvcmxkIQ==&quot;} } }  "},{"title":"Bool​","type":1,"pageTitle":"Properties","url":"docs/v7/properties/#bool","content":"For both implicit and explicit values, the format is a boolean value. { &quot;$properties&quot;: { &quot;ImplicitExample&quot;: true, &quot;ExplicitExample&quot;: {&quot;Bool&quot;: false} } }  "},{"title":"BrickColor​","type":1,"pageTitle":"Properties","url":"docs/v7/properties/#brickcolor","content":"The BrickColor type cannot be specified implicitly. For explicit values, the format is an integer representing the Number of a BrickColor. { &quot;$properties&quot;: { &quot;ExplicitExample&quot;: {&quot;BrickColor&quot;: 194} } }  "},{"title":"CFrame​","type":1,"pageTitle":"Properties","url":"docs/v7/properties/#cframe","content":"For implicit values, the format is a flat list of components. { &quot;$properties&quot;: { &quot;ImplicitExample&quot;: [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 ] } }  For explicit values, the format is an object with position and orientation fields. { &quot;$properties&quot;: { &quot;ExplicitExample&quot;: { &quot;CFrame&quot;: { &quot;position&quot;: [1.0, 2.0, 3.0], &quot;orientation&quot;: [ [4.0, 5.0, 6.0], [7.0, 8.0, 9.0], [10.0, 11.0, 12.0] ] } } } }  "},{"title":"Color3​","type":1,"pageTitle":"Properties","url":"docs/v7/properties/#color3","content":"For both implicit and explicit values, the format is a list of R, G and B components, respectively. Each component is a float in the range [0, 1]. { &quot;$properties&quot;: { &quot;ImplicitExample&quot;: [ 0.6392156862745098, 0.6352941176470588, 0.6470588235294118 ], &quot;ExplicitExample&quot;: { &quot;Color3&quot;: [ 0.6392156862745098, 0.6352941176470588, 0.6470588235294118 ] } } }  "},{"title":"Color3uint8​","type":1,"pageTitle":"Properties","url":"docs/v7/properties/#color3uint8","content":"The Color3uint8 type cannot be specified implicitly. For explicit values, the format is a list of R, G and B components, respectively. Each component is an integer in the range [0, 255]. { &quot;$properties&quot;: { &quot;ExplicitExample&quot;: { &quot;Color3uint8&quot;: [163, 162, 165] } } }  "},{"title":"ColorSequence​","type":1,"pageTitle":"Properties","url":"docs/v7/properties/#colorsequence","content":"The ColorSequence type cannot be specified implicitly. For explicit values, the format is an object with a keypoints field, which is an array of ColorSequenceKeypoints. Each ColorSequenceKeypoint is an object with time and color fields. The color field is a Color3. { &quot;$properties&quot;: { &quot;ExplicitExample&quot;: { &quot;ColorSequence&quot;: { &quot;keypoints&quot;: [ { &quot;time&quot;: 0.0, &quot;color&quot;: [1.0, 1.0, 0.5] }, { &quot;time&quot;: 1.0, &quot;color&quot;: [0.0, 0.0, 0.0] } ] } } } }  "},{"title":"Content​","type":1,"pageTitle":"Properties","url":"docs/v7/properties/#content","content":"For both implicit and explicit values, the format is a string. { &quot;$properties&quot;: { &quot;ImplicitExample&quot;: &quot;rbxassetid://12345&quot;, &quot;ExplicitExample&quot;: {&quot;Content&quot;: &quot;rbxassetid://12345&quot;} } }  "},{"title":"Enum​","type":1,"pageTitle":"Properties","url":"docs/v7/properties/#enum","content":"For implicit values, the format is a string corresponding to the name of the enum item. For example: { &quot;$className&quot;: &quot;SurfaceLight&quot;, &quot;$properties&quot;: { &quot;Face&quot;: &quot;Front&quot; } }  For explicit values, the format is an integer corresponding to the value of the enum item. For example: { &quot;$className&quot;: &quot;SurfaceLight&quot;, &quot;$properties&quot;: { &quot;Face&quot;: { &quot;Enum&quot;: 5 } } }  "},{"title":"Faces​","type":1,"pageTitle":"Properties","url":"docs/v7/properties/#faces","content":"The Faces type cannot be specified implicitly. For explicit values, the format is a list of strings, each of which may be either &quot;Right&quot;, &quot;Top&quot;, &quot;Back&quot;, &quot;Left&quot;, &quot;Bottom&quot;, or &quot;Front&quot;. Each string sets the corresponding component. { &quot;$properties&quot;: { &quot;ExplicitExample1&quot;: {&quot;Faces&quot;: [&quot;Right&quot;, &quot;Top&quot;, &quot;Back&quot;, &quot;Left&quot;, &quot;Bottom&quot;, &quot;Front&quot;]}, &quot;ExplicitExample2&quot;: {&quot;Faces&quot;: [&quot;Right&quot;, &quot;Top&quot;, &quot;Front&quot;]}, &quot;ExplicitExample3&quot;: {&quot;Faces&quot;: []} } }  "},{"title":"Float32​","type":1,"pageTitle":"Properties","url":"docs/v7/properties/#float32","content":"For both implicit and explicit values, the format is a number. { &quot;$properties&quot;: { &quot;ImplicitExample&quot;: 15.0, &quot;ExplicitExample&quot;: {&quot;Float32&quot;: 15.0} } }  "},{"title":"Float64​","type":1,"pageTitle":"Properties","url":"docs/v7/properties/#float64","content":"For both implicit and explicit values, the format is a number. { &quot;$properties&quot;: { &quot;ImplicitExample&quot;: 15123.0, &quot;ExplicitExample&quot;: {&quot;Float64&quot;: 15123.0} } }  "},{"title":"Int32​","type":1,"pageTitle":"Properties","url":"docs/v7/properties/#int32","content":"For both implicit and explicit values, the format is an integer. { &quot;$properties&quot;: { &quot;ImplicitExample&quot;: 6014, &quot;ExplicitExample&quot;: {&quot;Int32&quot;: 6014} } }  "},{"title":"Int64​","type":1,"pageTitle":"Properties","url":"docs/v7/properties/#int64","content":"For both implicit and explicit values, the format is an integer. { &quot;$properties&quot;: { &quot;ImplicitExample&quot;: 23491023, &quot;ExplicitExample&quot;: {&quot;Int64&quot;: 23491023} } }  "},{"title":"NumberRange​","type":1,"pageTitle":"Properties","url":"docs/v7/properties/#numberrange","content":"The NumberRange type cannot be specified implicitly. For explicit values, the format is a list of Min and Max components, respectively. Each component is a float. { &quot;$properties&quot;: { &quot;ExplicitExample&quot;: {&quot;NumberRange&quot;: [-36.0, 94.0]} } }  "},{"title":"NumberSequence​","type":1,"pageTitle":"Properties","url":"docs/v7/properties/#numbersequence","content":"The NumberSequence type cannot be specified implicitly. For explicit values, the format is an object with a keypoints field, which is an array of NumberSequenceKeypoints. Each ColorSequenceKeypoint is an object with time, value, and envelope fields. { &quot;$properties&quot;: { &quot;ExplicitExample&quot;: { &quot;NumberSequence&quot;: { &quot;keypoints&quot;: [ { &quot;time&quot;: 0.0, &quot;value&quot;: 5.0, &quot;envelope&quot;: 2.0 }, { &quot;time&quot;: 1.0, &quot;value&quot;: 22.0, &quot;envelope&quot;: 0.0 } ] } } } }  "},{"title":"OptionalCoordinateFrame​","type":1,"pageTitle":"Properties","url":"docs/v7/properties/#optionalcoordinateframe","content":"TODO "},{"title":"PhysicalProperties​","type":1,"pageTitle":"Properties","url":"docs/v7/properties/#physicalproperties","content":"The PhysicalProperties type cannot be specified implicitly. For explicit values, there are two formats. The constant string &quot;Default&quot;, which represents the default PhysicalProperties value. { &quot;$properties&quot;: { &quot;ExplicitExample&quot;: {&quot;PhysicalProperties&quot;: &quot;Default&quot;} } }  An object with fields corresponding to each component. { &quot;$properties&quot;: { &quot;ExplicitExample&quot;: { &quot;PhysicalProperties&quot;: { &quot;density&quot;: 0.5, &quot;friction&quot;: 1.0, &quot;elasticity&quot;: 0.0, &quot;frictionWeight&quot;: 50.0, &quot;elasticityWeight&quot;: 25.0 } } } }  "},{"title":"ProtectedString​","type":1,"pageTitle":"Properties","url":"docs/v7/properties/#protectedstring","content":"For both implicit and explicit values, the format is a string. { &quot;$properties&quot;: { &quot;ImplicitExample&quot;: &quot;print('Hello world!')&quot;, &quot;ExplicitExample&quot;: {&quot;ProtectedString&quot;: &quot;print('Hello world!')&quot;} } }  "},{"title":"Ray​","type":1,"pageTitle":"Properties","url":"docs/v7/properties/#ray","content":"The Ray type cannot be specified implicitly. For explicit values, there are several possible formats. An object with origin and direction fields. Each component is a Vector3. { &quot;$properties&quot;: { &quot;ExplicitExample&quot;: { &quot;Ray&quot;: { &quot;origin&quot;: [1.0, 2.0, 3.0], &quot;direction&quot;: [4.0, 5.0, 6.0] } } } }  A list of Origin and Direction components, respectively. Each component is a Vector3. { &quot;$properties&quot;: { &quot;ExplicitExample&quot;: { &quot;Ray&quot;: [ [1.0, 2.0, 3.0], [4.0, 5.0, 6.0] ] } } }  "},{"title":"Rect​","type":1,"pageTitle":"Properties","url":"docs/v7/properties/#rect","content":"The Rect type cannot be specified implicitly. For explicit values, the format is a list of Min and Max components, respectively. Each component is a Vector2. { &quot;$properties&quot;: { &quot;ExplicitExample&quot;: { &quot;Rect&quot;: [ [0.0, 5.0], [10.0, 15.0] ] } } }  "},{"title":"Ref​","type":1,"pageTitle":"Properties","url":"docs/v7/properties/#ref","content":"Not implemented. "},{"title":"Region3​","type":1,"pageTitle":"Properties","url":"docs/v7/properties/#region3","content":"Not implemented. "},{"title":"Region3int16​","type":1,"pageTitle":"Properties","url":"docs/v7/properties/#region3int16","content":"Not implemented. "},{"title":"SharedString​","type":1,"pageTitle":"Properties","url":"docs/v7/properties/#sharedstring","content":"Not implemented. "},{"title":"String​","type":1,"pageTitle":"Properties","url":"docs/v7/properties/#string","content":"For both implicit and explicit values, the format is a string. { &quot;$properties&quot;: { &quot;ImplicitExample&quot;: &quot;Hello, world!&quot;, &quot;ExplicitExample&quot;: {&quot;String&quot;: &quot;Hello, world!&quot;} } }  "},{"title":"Tags​","type":1,"pageTitle":"Properties","url":"docs/v7/properties/#tags","content":"For both implicit and explicit values, the format is a list of strings, where each string is a tag. { &quot;$properties&quot;: { &quot;ImplicitExample&quot;: [&quot;foo&quot;, &quot;con'fusion?!&quot;, &quot;bar&quot;], &quot;ExplicitExample&quot;: {&quot;Tags&quot;: [&quot;foo&quot;, &quot;con'fusion?!&quot;, &quot;bar&quot;]} } }  "},{"title":"UDim​","type":1,"pageTitle":"Properties","url":"docs/v7/properties/#udim","content":"The UDim type cannot be specified implicitly. For explicit values, the format is a list of Scale and Offset components, respectively. Scale is a float, and Offset is an integer. { &quot;$properties&quot;: { &quot;ExplicitExample&quot;: {&quot;UDim&quot;: [1.0, 32]} } }  "},{"title":"UDim2​","type":1,"pageTitle":"Properties","url":"docs/v7/properties/#udim2","content":"The UDim2 type cannot be specified implicitly. For explicit values, the format is a list of X and Y components, respectively. Each component is a UDim. { &quot;$properties&quot;: { &quot;ExplicitExample&quot;: {&quot;UDim2&quot;: [[-1.0, 100], [1.0, -100]]} } }  "},{"title":"Vector2​","type":1,"pageTitle":"Properties","url":"docs/v7/properties/#vector2","content":"For both implicit and explicit values, the format is a list of X and Y components, respectively. Each component is a float. { &quot;$properties&quot;: { &quot;ImplicitExample&quot;: [-50.0, 50.0], &quot;ExplicitExample&quot;: {&quot;Vector2&quot;: [-50.0, 50.0]} } }  "},{"title":"Vector2int16​","type":1,"pageTitle":"Properties","url":"docs/v7/properties/#vector2int16","content":"For both implicit and explicit values, the format is a list of X and Y components, respectively. Each component is an integer. { &quot;$properties&quot;: { &quot;ImplicitExample&quot;: [-300, 300], &quot;ExplicitExample&quot;: {&quot;Vector2int16&quot;: [-300, 300]} } }  "},{"title":"Vector3​","type":1,"pageTitle":"Properties","url":"docs/v7/properties/#vector3","content":"For both implicit and explicit values, the format is a list of X, Y, and Z components, respectively. Each component is an float. { &quot;$properties&quot;: { &quot;ImplicitExample&quot;: [-300.0, 0.0, 1500.0], &quot;ExplicitExample&quot;: {&quot;Vector3&quot;: [-300.0, 0.0, 1500.0]} } }  "},{"title":"Vector3int16​","type":1,"pageTitle":"Properties","url":"docs/v7/properties/#vector3int16","content":"For both implicit and explicit values, the format is a list of X, Y, and Z components, respectively. Each component is an integer. { &quot;$properties&quot;: { &quot;ImplicitExample&quot;: [60, 37, -450], &quot;ExplicitExample&quot;: {&quot;Vector3int16&quot;: [60, 37, -450]} } }  "},{"title":"Upgrading From Rojo 6","type":0,"sectionRef":"#","url":"docs/v7/upgrade/","content":"","keywords":""},{"title":"Explicit Properties in Project/Meta Files​","type":1,"pageTitle":"Upgrading From Rojo 6","url":"docs/v7/upgrade/#explicit-properties-in-projectmeta-files","content":"Rojo has support for specifying properties in project files as well as .meta.json files. There are two ways to write properties in these files, the explicit syntax and implicit syntax. Rojo's implicit syntax has not changed. In Both Rojo 6 and 7, you can write properties like this: { &quot;name&quot;: &quot;cool-skateboard&quot;, &quot;tree&quot;: { &quot;$className&quot;: &quot;Part&quot;, &quot;$properties&quot;: { &quot;Material&quot;: &quot;Wood&quot;, &quot;Size&quot;: [2, 0.5, 6], &quot;Color&quot;: [1, 0, 0], &quot;CFrame&quot;: [ 0, 10, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1 ] } } }  info It's strongly recommended to use the implicit syntax when possible! It's shorter, easier to read, and more future-proof. Rojo also has a more explicit syntax for specifying property values. This syntax should be used only for a couple reasons: Using an new enum value that Rojo doesn't know about.Writing a property with a different value type than what Rojo expects. In Rojo 6, this same model using the explicit property syntax would look like this: { &quot;name&quot;: &quot;cool-skateboard&quot;, &quot;tree&quot;: { &quot;$className&quot;: &quot;Part&quot;, &quot;$properties&quot;: { &quot;Material&quot;: { &quot;Type&quot;: &quot;Enum&quot;, &quot;Value&quot;: 512 }, &quot;Size&quot;: { &quot;Type&quot;: &quot;Vector3&quot;, &quot;Value&quot;: [2, 0.5, 6] }, &quot;Color&quot;: { &quot;Type&quot;: &quot;Color3&quot;, &quot;Value&quot;: [1, 0, 0] }, &quot;CFrame&quot;: { &quot;Type&quot;: &quot;CFrame&quot;, &quot;Value&quot;: [ 0, 10, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1 ] } } } }  This format has changed in Rojo 7. The same model with Rojo 7's explicit property syntax would look like this: { &quot;name&quot;: &quot;cool-skateboard&quot;, &quot;tree&quot;: { &quot;$className&quot;: &quot;Part&quot;, &quot;$properties&quot;: { &quot;Material&quot;: { &quot;Enum&quot;: 512 }, &quot;Size&quot;: { &quot;Vector3&quot;: [2, 0.5, 6] }, &quot;Color&quot;: { &quot;Color3&quot;: [1, 0, 0] }, &quot;CFrame&quot;: { &quot;CFrame&quot;: { &quot;position&quot;: [0, 10, 0], &quot;orientation&quot;: [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ] } } } } }  In Rojo 7, the Type and Value fields were folded together to reduce the amount of typing. Some types like CFrame and ColorSequence had fields added or renamed. Since the release of Rojo 6, it has been feasible to use rbxm or rbxmx files for models instead of typing properties by hand. For more complicated models, this is recommended. "},{"title":"Recomended Workflows","type":0,"sectionRef":"#","url":"docs/v7/workflows/","content":"","keywords":""},{"title":"Development Places​","type":1,"pageTitle":"Recomended Workflows","url":"docs/v7/workflows/#development-places","content":"Many Roblox developers collaborate using Team Create. While Team Create is great for collaborative building and newer developers, it is also prone to issues. What workflow you migrate to depends on how much of your game you would like Rojo to manage. If you just want to use Rojo to manage your game's scripts, and leave everything else managed by Team Create or a similar feature, that is called Partially Managed Rojo. If you want to manage your entire game with Rojo and reap all of its benefits like continuous deployment and hermetic builds, that is called Fully Managed Rojo. "},{"title":"Partially Managed Rojo​","type":1,"pageTitle":"Recomended Workflows","url":"docs/v7/workflows/#partially-managed-rojo","content":"Best practice is still being developed here, but it is generally recommended that each programmer on a project have their own place to work in. TODO "},{"title":"Fully Managed Rojo​","type":1,"pageTitle":"Recomended Workflows","url":"docs/v7/workflows/#fully-managed-rojo","content":"TODO "}]